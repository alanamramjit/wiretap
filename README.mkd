# Wiretap

Wiretap is a project meant to trace information of running a java
program. This information can be used to create dynamic analyses that
can run after the fact. This project aims to

- scale, it needs to run fast;
- be extendable, it can track different things;
- thread safe;
- and be re-playable, so a trace can be reproduced.

## Getting Started

Wiretap is implemented as a java agent. To run it write

```
java -javaagent:wiretap.jar .. normal parameters 
```

This will by default create a wiretap folder `_wiretap/`, which will contain
logs of the execution of the program. As a default the program will log enough
to be able to replay itself.

If you have build the test submodule `baseline`, then you can test it all with
this command:

```
java -javaagent:build/wiretap.jar \
  -cp test/baseline/build/baseline.jar \
  edu.ucla.pls.baseline.Transfer
```

## Output Defined

The `_wiretap/` folder contain these files:

- `classes.txt` a list of classes encountered by wiretap, in chronological order.
- `methods.txt` a list of methods instrumented by wiretap. The methods are
  formatted like this:
  ```
  <FullyQualifiedMethod>(<Signature>)<ReturnType>[+<GenericSignature>][!<FullyQualifiedException>]*
  ```
  Stuff that still needs to be worked on: 
  [ ] Find a good way to represent the GenericSignature, Should it replace the
      Signature?
  [ ] Also there is the private/public access flag, that needs to be represented 
      in a fancy way.
      
- `log/`, this is where the fun happens. Each logger will add events to one of
  the files in this directory. The files are numerated by thread. The events of
  different threads are stored in different files to reduce the needed for
  synchronization.


## Wiretaps 

All wiretaps inherit from the basic `Wiretap`. Each Wiretap logs information about the 
execution of the program, but should not interfere with each other. A wiretap should be
self contained. This means that it will both instruments the code and contain the static
methods that the instrumented code can access. Dynamic state is allowed, but should be in 
an extra class in the same file.

All wiretaps are listed below.

### Basic wiretap

The basic wiretap logs information about forking and joining of threads. To do
this correctly the wiretap also has to track which methods are called and when
they are exited. This wiretap logs 7 kinds of events. 

- `fork`, a thread has been forked. 
  This is tracked by looking at `java/lang/Thread.start(Ljava/lang/Thread;)V`
  methods. When a thread is started a new event is created; a `fork` event
  pointing to the new thread. This event will also name the thread in the system, 
  so that future references are correlated.
   
- `join`, a thread has been joined. 
  This is a very simple logger, as it logs after
  `java/lang/Thread.join(Ljava/lang/Thread;)V`. Even though that there exists
  join methods where you can give a time out, they are not hard constraints and
  can therefor be safely ignored.

- `begin`, a thread has begun. 
  A thread can have any number of enter and exit points, especially if some of
  the code isn't instrumented. We assume that a thread has begun, when it enters
  the first method.

- `end`, a thread has ended.
  The best way to check if a thread has ended is to see if the method stack is
  empty. We track the method stack with the `enter` and `exit` events.

- `enter`, a thread has entered a method.
  Enter is easy, we simply emit an `enter` event as the first in each method.

- `exit`, a thread has exited a method.
  Exit is harder. It's easy to track `RETURN` instructions in the code, but a 
  method can also be exited using an exception, and caught in any layer in the 
  method stack.
  
  [ ] Find solution to this.
  
## Building from Source

Make sure that [asm-5.1.jar](http://asm.ow2.org/) is in `lib/`. Run `ant`.
Simple as that.

## Q&A

- Why not instrument before running the program? 
  The problem is that some programs hot-loads classes that did not statically 
  exist in the program before running the program. To cover all cases, and the
  actual behavior of the program we have to instrument as the classes are loaded
  by the class loader.

## Todos

[ ] Create a test that figures out if extended inherits graph and information is
    needed. The special case is the Thread.start(). Is it possible that if a
    class extends Thread that the implementation won't catch that. 
